# 서 민수
### 202530217

# 11월20일강의
- ## 트리 관련 용어
-  트리를 구성하는 요소는 노드와 가지
- 각각의 노드는 가지를 통해 연결되어있음
- 리프
- ## 트리 관련 용어
- ### 자식
- 어떤 노드로부터 가지로 연결된 아래쪽 노드
- 노드는 자식을 여러 개 가질 수 있음 
- ### 부모
- 어떤 노드에서 가지로 연결된 가장 위쪽 노드
- 노드는 1개의 부모를 가짐
- ### 형제
- 같은 부모를 가진 노드
- ### 조상

- ### 자손

- ### 레벨
- 루트로부터 얼마나 떨어져 있는지에 대한 값
- 루트의 레벨은 0이고 루트로부터 가지가 하나씩 아래로 뻗어나갈 때마다 레벨이 1씩 늘어남
- ### 차수
- 노드가 갖는 자식의 수
- 모든 노드으; 차수가 n 이하면 트리를 n진 트리라고 함
- ### 높이
- 루트부터 가장 멀리 떨어진 리프까지의 거리
- ### 서브 트리
- 트리 안에서 다시 어떤 노트를 루트로 정하고 그 자손으로 이루어진 트리
- ### 널 트리
- 노드 가지가 없는 트리
- ### 순서 트리와 무순서 트리
- 형제 노드의 순서가 있는지 없는지에 따라 트리를 두 종류로 분류
- ### 너비 우선 탐색
- 낮은 레벨에서 시작해 왼쪽에서 오른쪽 반향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려감
- ### 깊이 우선 탐색
- 리프까지 내려가면서 검색하는 것을 우선순위로 하는 탐색 방법
- 리프에 도달해서 더 이상 검색을 진행 곳이 없는 경우에는 부모에게 돌아감
- 그런 다음에 다시 자식 노드로 내려감
- ## 깊이 우선 탐색에서 가능한 노드 방문 종류
- 전위 순회
- 중위 순회
- 후위 순회
- ### 이진트리(중요)
- 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리
- 노드의 자식은 2명 이하만 우지해야함
- 왼쪽자식과 오른쪽 자식을 구분함
- 왼쪽자식을 다시 루트로 하는 서브 트리를 왼쪽 서브 트리, 오른쪽 자식을 다시 루트로 하는 서브 트리를 오른쪽 서브 트리 라고함
- ### 완전이진트리
- 루트부터 노드다 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리
- 1. 마지막 레벨을 제외한 레벨은 노드를 가즉 채움
- 2. 마지막 레벨은 왼쪽부터 오른쪽 반향으로 노드를 태우되 반드시 끝까지 채울 필요는 없음
- 따라서 n개의 노드를 저장할수 있는 완전이진트리의 높이는 log n

- # 보충
- 트리의 레벨은 루트에서부터 노드까지 거친 층의 수를 나타내며, 루트는 보통 0레벨 또는 1레벨로 본다.
- 높이는 트리의 최대 레벨과 같으며, 루트에서 가장 먼 리프 노드까지의 경로에 있는 레벨 수(혹은 간선의 최대 개수)를 의미한다.

- ### 이진 검색 트리
- 
- ### 이진트리의 특징
- 구조가단순함,
- 중위순회를 하면 키값의 오름차순으로 노드를 얻을수 있음,
- 이진검색과 비슷한 방식으로 빠르게 검색할 수 있음,
- 노드를삽입하기 쉬움

- ### 이진검색 트리 만들기
- 자식 노드가 1개인 노드를 삭제하는 경우
- 자식노드가 2개인 노드를 삭제하는 경우
- 정렬된 배열에 데이터를 추가

- ### 해시법
- 요소룰 삭제시키는 함수

- ### 오픈 주소법


# 11월13강의

- ## 강의 진도
- 현재 6장까지 완료 앞으로 자료구조 기본내용만 강의.

- 7장은 문자열 검색 알고리즘 관한 내용
- 8장 리스트는 전형적인 자료 구조 입니다.
- 9장 트리도 전형적인 자료구조
- 10장은 자료구조의 응용입니다.따라서 생략합니다

- 8장
- 선형리스트,포인터를 이용한 연결 리스트,커서를 이용한 연결 리스트,원형 이중 리스트

- # 08-1 선형 리스트
- ## 리스트
- 데이터를 순서대로 나욜해 놓은 자료구조
- 가장 단순한 구조를 가진 리스트를 선형 리스트 또는 연결 리스트 라고 함

- ## 노드
- 리스트의 각 요소
- 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있음
- 처음과 끝에 있는 노드는 특별히 각각 머리(head) 노드,꼬리(tail node) 노드 라고함

- ## 다음 노드 꺼내기
- 배열의 각 요소에는 연락할 순서대로 데이터가 저장
- 전화를 걸기 위해 필요한 다음 노드 꺼내기는 1만큼 큰 인덱스를 갖는 요소에 접근하면 됨

- 노드의 삽입과 삭제
- 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 함
- 데이터의 삽입,삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음

- ## 노드용 구조체
- 노드용 객체를,연결 리스트에 데이터를 삽입할 떄 만들고 삭제할 때 없애면, 앞에서 제시한데이터를 밀고 당기는 문제를 해결할 수 있음.
-  





















# 11월06강의

- 테크페어 사진

![이미지](/사진/20251106_123453.jpg)
![이미지](/사진/20251106_123502.jpg)
![이미지](/사진/20251106_123504.jpg)
![이미지](/사진/20251106_123617.jpg)
![이미지](/사진/20251106_123625.jpg)
![이미지](/사진/20251106_123627.jpg)
![이미지](/사진/20251106_123906.jpg)
![이미지](/사진/20251106_124201.jpg)



- ## 1단계 도수분포표 만들기
- 배열 a를 바텅으로 각 점수에 해당하는 학생이 몇명인지를 나타내는 도수분표포를 작성
- 도수분포표를 나타내기 위해 배열을

- ## 

- ## 도수 정렬
- 지금까지의 정렬 알고리즘은 두 요소의 키값을 비교해야 했음
- 도수 정렬은 요소를 비교할 필요가 없다는 특징이 있음

- ## 도수 정렬 알고리즘
- 도수분포표 만들기
- 누적도수분포표 만들기
- 목적 배열 만들기
- 배열 복사하기

- ## 트리의 종류와 힙
- 최대힙은 부모 노드가 자식 노드보다 큰 경우를 말한다.최소힙은 반대.
- 절대힙은 부모 노드가 자식보다 큰 경우를 말한다.최소힙의 반대.

- ## 루트를 없애고 힙 상태 유지하기
- 루트를 없앤 다움 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 하는데 그 순서는 다음과 같음
- 1.루트를꺼냄
- 2.마지막 요소를 루트로 이동
- 3.자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽 으로 내려가는 작업을 반복하는데 이떄 자식의 값이 작거나 잎에 다다르면 작업이 종료됨

- ## 힙 정렬
- 가장 큰 값이 루트에 위치하는 특징을 이용하는 정렬 알고리즘
- 다음과 같은 작업을 반복해 그 과정에서 

- ## 힙의 요소를 배열에 저장
- 

- ## 힙
- 부모의 값이 자식의 값보다 항상 크다 는 조건을 만족하는 완전 이진트리
- 형제 사이의 대소 관계는 일정하지 않음

- ## 배열 정렬
- 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
- 먼저 배열을 앞부분과 뒷부분으로 나눔
- 나눈 두 배열을 각각 정렬하고 병합하면 배열 모두를 정렬할 수 있음

- ## 병합 정렬 알고리즘
- 배열의 요소 개수가 2개 이상인 경우
- 1.배열의 앞부분을 병합 정렬로 정렬
- 2.배열의 뒷부분을 병합 정렬로 정렬
- 3.배열의 앞부분과 뒷부분을 병합

- 배열 a에서 선택한 요소와 배열 b에서 선택한 요소(b[pb])를 비교하여 작은 값을 c[pc]에 저장

- ### qsort 함수
- qsort함수는 bsearch 함수와 마찬가지로 int 형이나 double형 등의 배열뿐만 아니라 구조체형 배열 등 모든 자료형의 배열에 적용할 수 있음
- qsort 함수에 전달하는 4개의 인수는 앞으로부터 차례 대로 배열의 첫 번째요소에 대한 포인터 요소의 개수 요소의크기 비교함수에 대한 포인터

- 병합 merge
- #a, b 모두 정렬이 끝난 배열이 조건!
- 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업을 반복하여 정렬을 마치는 배열을 만듦
- merge 함수는 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장
- 처음 요소에는 첫 요소를 선택하므로 커서를 모두 0으로 초기화

# 10월31강의
## 단순 선택 정렬
- 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번쨰 요소와 교환

## 교환과정
- 1.아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min])을 선택
- 2.a[min]과 아직 정렬하지 않은 부분의 첫 번쨰 요소를 교환

## 단순 삽입 정렬
- 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입라는 작업을 반복하여 정렬하는 알고리즘
- 아직 정렬되지 않은 부분의 첫번쨰 요소를 정렬된 부분의 알맞은 위치에 삽입

## 단순 삽입 정렬의 특징
- 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐(장점)
- 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐(단점)

## 셀 정렬
- 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
- 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 산입 정렬을 수행
- 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법

## 정렬-1
- 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법
- 아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐

## 정렬-2
- 2칸 만큼 떨어진 요소를 모아 두 구룹으로 나누어 2-정렬 을함

## h-정렬
- 셀 정렬 과정에서 수행하는 각각의 정렬

## 중분값(h값)의 선택
- h값은 n부터 감소하여 마지막에 1이 되면 됨
- 이렇게 그룹이 섞이지 않으면 c를 합쳤을 떄 다시 처음 단계인 a와 동일한 상태가 됨

## 퀵 정렬
- 일반적으로 사용되는 있는 아주 빠즌 정렬 알고리즘
- 퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 ㄷ되면 정렬을 마침

## 배열을 두 그룹으로 나누기
- 그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야 함
- pl고ㅓpr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 아래처럼 두 그룹으로 나누어짐

## 피벗과 같은 값을 가지는 그룹
- 그룹을 나누는 작업이 끝난 다음 pl> pr + 1인 경우 다음과 같은 그룹이 생길 수 있음
- 1.a[p] >= x가 성립하는 요소를 찾을 떄까지 pr을 오른쪽으로 옮김



# 10월30강의
## 스택이란?
- ## 스택
- 데이터를 일시적으로 지정하기 위해 사용하는 자료구조
- 데이터의 입력과 출력 순서는 후입선출(LIOF, Last In First Out)
- 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄
- 푸시(push):스택에 데이터를 가장 먼저 꺼냄
- 팝(pop): 스택에서 데이터를 꺼내는 작업
- 꼭대기(top): 푸시,팝을 하는 위치
- 바닥(bottom): 스택의 가장 밑바닥 부분

- ## 스택의 구현 예
- 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
- 가장 먼저 main 함수를 실행하며 mian 함수는 z 함수를 호출
- 호출된 함수 z는 x함수와 y함수를 순서대로 호출
- 함수를 호출할 때는 푸시하고 함수가 실행을 종료하고 호출한 원래의 함수로 돌아갈 때는 종료할 함수를 팝함

- ## 스택 구조체 IntStack
- 스택으로 사용할 배열을 가리키는 포인터 stk
- 인덱스가 0인 요소를 스택의 바닥이라 함
- 배열의 메모리 공간 할당은 Initialize 함수로 생성
- ### 스택의 최대 용량max
- 배열 ptr의 요소
- ### 스택 포인터ptr
- 스택에 쌓여 있는 데이터의 개수를 나타냄
- 스택이 비어 있으면 ptr의 값은 0이고 가득 차 있으면 max

# 큐 란?
- ## 큐
- 데이터를 일시적으로 쌓아 두기 위한 자료구조
- 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조를 이룸
- 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열과 같음
- 인큐: 큐에 데이터를 넣는작업
- 디큐: 데이터를 꺼내는 작업
- 프런트: 데이터를 꺼내는 쪽
- 리어: 데이터를 넣는 쪽

- ## 큐의 구현 예
- 배열의 프런트부터 4개의 데이터가 들어가 있는 모습

- ## 링 버퍼
- 배열의 처음이 끙과 연결되었다고 보는 자료구조
- 프런트:논리적인 맵 처음 요소의 인덱스
- 리어: 논리적인 맨 끝 요소의 하나 뒤의 인덱스
- 변수 프런트와 리어의 값은 인큐와 디큐를 수행함에 따라 변화하는데 이 때문에 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현할수있음
- 원형큐란 데이터를 이동시키지않고도 이동시키는것 같은 효과를 보인다

- ## 링 버퍼로 큐 만들기
- ## 모든 데이터를 출력하는 함수 Print
- 큐의 모든 데이터를 처음부터 끝까지 순서대로 출력하는 함수

- ## 종료 함수 Terminate
- 메모리 공간에 할당한 배열(큐)을 해제하는 함수

- ## 정렬
- 이름,학번,키 등의 핵심 항목의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
- 키값이 적은 데이터를 앞쪽에 놓으면 오름차순정렬,그 반대로 놓으면 내림차순 정렬이라고 부름
- *정렬 알고리즘의 안정성*
- 안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것
- *정렬 알고리즘의 핵심 요소*
- 교환,선택,삽입

- # 버블 정렬 알아보기
- ## 패스
- 요소의 개수가 n개인 배열에서 n-1회 비교,교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동함
- 이런 일련의 과정(비교,교환 작업)을 패스 라고함

- 패스 수행 횟수

# 10월23강의
*검색 알고리즘이란?* 
* **주소록 검색**
- 이러한 검색의 공통점은 특정 항목에 주목한다는점
- 그 주목하는 항목을 키(key)라고 함
*배열 검색*
- 선형 검색:무작위로 늘어놓은 데이터의 모임에서 검색을 수행
- 이진 검색:일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
- 해시법:추가,삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
- 체인법:같은 해시값의 데이터를 선형 리스트로 연결하는 방법
- 오픈 주소법:데이터를 위한 해시값이 충돌할 때 재해시하는 방법
*선형 검색 또는 순차 검색*
- 요소가 직선 모양으로 늘어선 배열에서의 검색은 원하는 키값을 갖는 요소를 만날 때까지 앞부터 순서대로 요소를 검색
*보초법으로 검색 다루기*
*보초법*
종료 조건을 검사하는 비용을 반(50%)으로 줄이는 방법
*정렬된 배열에서 검색하는 bsearch 함수 알아보기*
- bsearch
- C언어의 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공

# 10월02일 강의
배열 요소를 역순으로 정렬
다차원 배열
배열을 요소로 하는 배열
배열을 자료형으로 하면 2차원 배열이고, 2차원 배열을 자료형으로 하면 3차원 배열

1차원 배열 : 지금까지 배운 '단일 자료형을 가지는 배열'

2차원 배열의 도출
[a] int형 int 자료형
[b] int[3]형 int를 자료형으로 하는 단일 요소가 3개인 배열
[c] int[4][3]형 int를 자료형으로 하는 단일 요소가 3개인 배열을 자료형으로 하는 요소 개수가 4개인 배욜

구조체란?
# 09월25일 강의
배열이란?

# 09월18일 강의


# 09월11일 강의


# 09월-04일



# [문자 크기](#h1에-해당) / [리스트](#리스트)

```md
# h1에 해당
## h2
### h3
#### h4
##### h5
###### h6
```


*이탤릭 체*  
**볼드 체**  
***하이픈***  
---
* 언오더드 리스트
- 언  
    *탭  
    *탭  
        *탭  
        *탭

1. 오더드 리스트
2. 

# 코드 블럭

```c
#include <stdio.h>

int main()
{
    printf("Hello, world")

}
```
인라인 코드 블럭 예 : `<br>` 다른예 : `Ctrl`+`A`

#와부링크
[구글로 가기](https://google.com "구글 링크")
# [내부](#)

![이미지](/1.jpg "이미지 삽입")